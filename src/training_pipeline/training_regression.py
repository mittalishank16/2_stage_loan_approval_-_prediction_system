import os
import pandas as pd
import numpy as np
import joblib
from pathlib import Path
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor, ExtraTreesRegressor
from sklearn.model_selection import cross_val_score
import xgboost as xgb

# --- Configuration ---
PROCESSED_DATA_DIR = Path("data/feature_engineered_pipeline")
MODEL_DIR = Path("models")
MODEL_DIR.mkdir(parents=True, exist_ok=True)

class RegressionTrainer:
    def __init__(self, train_path, test_path):
        self.train_path = train_path
        self.test_path = test_path
        self.target = 'Loan Sanction Amount (USD)'
        self.models = {
            "RandomForest": RandomForestRegressor(n_estimators=100, random_state=42),
            "ExtraTrees": ExtraTreesRegressor(n_estimators=100, random_state=42),
            "GradientBoosting": GradientBoostingRegressor(random_state=42),
            "XGBoost": xgb.XGBRegressor(objective='reg:squarederror', random_state=42)
        }

    def load_data(self):
        """Loads the pre-split regression data generated by ingestion.py"""
        train_df = pd.read_csv(self.train_path)
        test_df = pd.read_csv(self.test_path)
        
        X_train = train_df.drop(columns=[self.target])
        y_train = train_df[self.target]
        X_test = test_df.drop(columns=[self.target])
        y_test = test_df[self.target]
        
        return X_train, X_test, y_train, y_test

    def compare_models(self, X_train, y_train):
        """Performs cross-validation to find the best performing base model."""
        print("--- Comparing Models via Cross-Validation (RMSE) ---")
        results = {}
        for name, model in self.models.items():
            # Using negative mean squared error as cross_val_score maximizes value
            cv_scores = cross_val_score(model, X_train, y_train, cv=5, scoring='neg_root_mean_squared_error')
            results[name] = -cv_scores.mean()
            print(f"{name}: RMSE = {-cv_scores.mean():.4f}")
        
        best_model_name = min(results, key=results.get)
        print(f"\nBest Model Found: {best_model_name}")
        return best_model_name

    def train_and_save_final_model(self, X_train, X_test, y_train, y_test, model_name):
        """Trains the chosen model and saves it to the models directory."""
        print(f"--- Training Final {model_name} Model ---")
        model = self.models[model_name]
        model.fit(X_train, y_train)
        
        # Evaluate
        preds = model.predict(X_test)
        rmse = np.sqrt(mean_squared_error(y_test, preds))
        mae = mean_absolute_error(y_test, preds)
        r2 = r2_score(y_test, preds)
        
        print(f"Final Evaluation Metrics:")
        print(f"RMSE: {rmse:.4f} | MAE: {mae:.4f} | R2 Score: {r2:.4f}")
        
        # Save artifact
        model_path = MODEL_DIR / "regression_model.pkl"
        joblib.dump(model, model_path)
        print(f"âœ… Model saved to {model_path}")

def run_regression_training():
    trainer = RegressionTrainer(
        train_path=PROCESSED_DATA_DIR / "train_regression_data.csv",
        test_path=PROCESSED_DATA_DIR / "test_regression_data.csv"
    )
    
    # Execute Flow
    X_train, X_test, y_train, y_test = trainer.load_data()
    best_name = trainer.compare_models(X_train, y_train)
    trainer.train_and_save_final_model(X_train, X_test, y_train, y_test, best_name)

if __name__ == "__main__":
    run_regression_training()